<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: c | 812lcl的博客]]></title>
  <link href="http://812lcl.com/blog/tags/c/atom.xml" rel="self"/>
  <link href="http://812lcl.com/"/>
  <updated>2014-03-31T20:31:23+08:00</updated>
  <id>http://812lcl.com/</id>
  <author>
    <name><![CDATA[812lcl]]></name>
    <email><![CDATA[812liuchunlei@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[重学C语言(四)——变量初始化]]></title>
    <link href="http://812lcl.com/blog/2013/12/28/zhong-xue-cyu-yan-si-bian-liang-chu-shi-hua/"/>
    <updated>2013-12-28T14:36:00+08:00</updated>
    <id>http://812lcl.com/blog/2013/12/28/zhong-xue-cyu-yan-si-bian-liang-chu-shi-hua</id>
    <content type="html"><![CDATA[<p>首先来声明几个概念：</p>

<p>存储类说明符：</p>

<p><code>auto  register  static  extern  typedef</code></p>

<p>类型说明符：</p>

<pre><code>void  char  short  int  long  float  double  
signed  unsigned  结构或联合说明符  
枚举说明符  类型定义名
</code></pre>

<p>类型限定符：</p>

<p><code>const  volatile</code></p>

<!--more-->


<h2>存储类</h2>

<p>存储类分为两类：自动存储类（automatic）和静态存储类（static）。声明对象时使用的一些关键字和声明的上下文共同决定了对象的存储类。自动存储类对象对于一个程序块来说是局部的，在退出程序块时该对象将消失。如果没有使用存储类说明符，或者使用了auto限定符，则程序块中的声明生成的都是自动存储类对象。声明为register的对象也是自动存储类对象，暗示了声明的对象将被频繁地访问。只有很少的对象被真正存放在在机器的快速寄存器中，并且只有特定的类型才可以。被声明为register的对象不能对它应用元运算符&amp;。</p>

<p>静态对象可以是某个程序块的局部对象，也可以是所有程序块的外部对象。无论是哪一种情况，在退出和再进入函数或程序块时其值将保持不变。静态变量只在第一次进入程序块时被初始化一次。在一个程序块（包含提供函数代码的程序块）内，静态对象用关键字static声明。在所有程序块外部声明且与函数定义在同一级的对象总是静态的。可以通过static关键字将对象声明为某个特定翻译单元的局部对象，这种类型的对象将具有内部链接。当省略显示的存储类或通过关键字extern进行声明时，对象对整个程序来说是全局可访问的，并且具有外部连接。函数内部的extern声明表明，被声明的对象的存储空间定义在其他地方。</p>

<h2>作用域规则</h2>

<p>名字的作用域指的是程序中可以使用该名字的部分。对于在函数开头声明的自动变量来说，其作用域是声明该变量的函数。不同函数中声明的具有相同名字的各个局部变量之间没有任何关系。函数的参数实际上可以看做是局部变量。</p>

<p>外部变量或函数的作用域从声明它的地方开始，到其所在的（带编译）的文件的末尾结束。</p>

<p>另一方面，如果要在外部变量的定义之前使用该变量，或外部变量的定义与变量的使用不在同一个源文件中，则必须在相应变量声明中强制性地使用关键字extern。</p>

<p>将外部变量的声明与定义严格区分开来很重要。变量声明用于说明变量的属性（主要是变量的类型），而变量定义除此以外还将引起存储器的分配。</p>

<p>在一个源程序的所有源文件中，一个外部变量只能在某个文件中定义一次，而其他文件可以通过extern声明来访问它（定义外部变量的源文件中也可以包含对该外部变量的extern声明）。外部变量的定义中必须指定数组的长度，但extern声明则不一定要指定数组的长度。</p>

<p>用static声明限定外部变量与函数，可以将其后声明的对象的作用域限定为被编译源文件的剩余部分。通过static限定外部对象，可以达到隐藏外部对象的目的。static类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量。</p>

<p>外部变量的初始化只能出现在其定义中。</p>

<p>在一个好的程序设计风格中，应该避免出现变量名隐藏外部作用域中相同名字的情况，否则，很可能引起混乱和错误。</p>

<h2>初始化</h2>

<p>声明对象时，对象的初始化声明符可以为其指定一个初始值。初值紧跟在运算符<code>=</code>之后，它可以是一个表达式，也可以是嵌套在花括号中的初值序列。初值序列可以以逗号结束，这样可以使格式简洁美观。</p>

<p>如果变量不是自动变量，则只能进行一次初始化操作，从概念上讲，应该是在程序开始执行之前进行，并且初始化表达式必须为常量表达式。每次进入函数或程序块时，显式初始化的自动变量都将被初始化一次，其初始化表达式可以是任何表达式。</p>

<p>对静态对象或数组而言，初值中的所有表达式必须是常量表达式。如果初值是用花括号括起来的初值表，则对auto或register类型的对象或数组来说，初值中的表达式也同样必须是常量表达式。但是自动对象的初值是一个单个的表达式，则它不必是常量表达式，但必须符合对象赋值的类型要求。</p>

<p>未显示初始化的静态对象将被隐式初始化，其效果等同于它（或它的成员）被赋以常量0。未显示初始化的自动对象的初始值没有定义。</p>

<p>指针或算数类型对象的初值是一个单个的表达式，也可能扩在花括号中。该表达式将被赋值给对象。</p>

<p>结构的初值可以是类型相同的表达式，也可以是扩在花括号中的按其成员次序排列的处置表。无名的位字段成员将被忽略，因此不被初始化。如果表中的初值的数目比结构的成员数少，则后面余下的结构成员将被初始化为0。初值的数目不能比成员数多。</p>

<p>数组的初值是一个括在花括号中的、由数组成员的初值构成的表。如果数组大小未知，则初值的数目将决定数组的大小，从而使数组类型成为完整类型。若数组大小固定，则初值的数目不能超过数组成员的数目。如果初值数目比数组成员数目少，则尾部余下的数组成员将被初始化为0。</p>

<p>联合的初值可以是类型相同的单个表达式，也可以是括在花括号中的联合的第一个成员的初值。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重学C语言(三)——复杂声明分析]]></title>
    <link href="http://812lcl.com/blog/2013/12/22/zhong-xue-cyu-yan-san-fu-za-sheng-ming-fen-xi/"/>
    <updated>2013-12-22T12:14:00+08:00</updated>
    <id>http://812lcl.com/blog/2013/12/22/zhong-xue-cyu-yan-san-fu-za-sheng-ming-fen-xi</id>
    <content type="html"><![CDATA[<p><a href="http://812lcl.github.io/blog/2013/12/21/zhong-xue-cyu-yan-er-yun-suan-fu-you-xian-ji-yu-ji-suan-shun-xu/">上一篇文章</a>是关于运算符的优先级的，这篇文章则来说说关于C语言中的复杂声明。C语言中的声明是不能从左往右读的，时而往左时而往右，有时候弄得人头大，什么数组指针、指针数组傻傻弄不清楚，函数指针更是模棱两可。复杂声明更是令人敬而远之了，常常被作为例子的就是系统调用里的signal函数了，它在signal.h中声明的，声明如下</p>

<pre><code>void (*signal(int, void(*)))(int);
</code></pre>

<p>是不是需要琢磨一番呢，其实在经典的C语言书籍中都很清楚地讲过这个问题了，C专家编程里讲得十分的好，而且这本书也十分的好，作者还时不时的小幽默一把。</p>

<!--more-->


<h2>1. 声明是如何形成的</h2>

<p>首先看一些C语言的术语以及一些能组合成一个声明的单独语法成分。其中一个非常重要的成分就是声明器(declarator)——它是所有声明的核心。简单的说，声明器就是标识符以及与它组合在一起的任何指针、函数括号、数组下标等。</p>

<p>声明器语法如下所示</p>

<pre><code>指针 opt 直接声明器
</code></pre>

<p>详细可见下表</p>

<pre><code>数量                C语言中的名字           C语言中的出现形式
-------------------------------------------------------------
零个或多个          指针                    下列形式之一：
                                            * const volatile
                                            * volatile
                                            *
                                            * const
                                            * volatile const
-------------------------------------------------------------
有且只有一个        直接声明器                   标识符
                                         或：标识符[下标]
                                         或：标识符(参数)
                                         或：(声明器)
</code></pre>

<p>一个声明由下表所示的各个部分组成（并非所有组合形式都是合法
的）。声明确定了变量的基本类型以及初始值（如果有）。</p>

<pre><code>数量                C语言中的名字           C语言中出现的名字
-------------------------------------------------------------
至少一个类型说明符     类型说明符            void char short int long
（并非所有组合都合法）  (type-specifier)    signed unsigned float double
                                        结构说明符(struct-specifier)
                                        枚举说明符(enum-specifier)
                                        联合说明符(union-specifier)
                    存储类型              extern static register
                    (storage-class)     auto typedef
                    类型限定符            const volatile
                    (type-qualifier)
-------------------------------------------------------------
有且只有一个          声明器                参见上表
-------------------------------------------------------------
零个或更多            更多的声明器          ,声明器
-------------------------------------------------------------
一个                 分号                ；
</code></pre>

<p>在合法的声明中存在限制条件，不可以像下面这样做：</p>

<ul>
<li><p>函数的返回值不能是一个函数</p></li>
<li><p>函数的返回值不能是一个数组</p></li>
<li><p>数组里面不能有函数</p></li>
</ul>


<p>但下面的是合法的：</p>

<ul>
<li><p>函数的返回值允许是一个函数指针</p></li>
<li><p>函数的返回值允许是一个指向数组的指针</p></li>
<li><p>数组里面允许有函数指针</p></li>
<li><p>数组里面允许有其他数组</p></li>
</ul>


<h2>2. 优先级规则</h2>

<p>上一节是讲声明的各个组成部分，本节描述了一种方法，用通俗的语言把声明分解开来，分别解释各个组成部分。要理解一个声明，必须要懂得其中的优先级规则(没错，又是优先级)，语言律师们最喜欢这种形式，它高度简洁，可惜即不直观。</p>

<p>理解C语言声明的优先级规则</p>

<pre><code>A   声明从它的名字开始读取，然后按照优先级顺序依次读取。
B   优先级从高到低依次是：
    B.1 声明中被括号括起来的部分
    B.2 后缀操作符：
        括号（）表示这是一个函数，而
        方括号[]表示这是一个数组。
    B.3 前缀操作符：`*`表示“指向...的指针”
C   如果const和（或）volatile关键字的后面紧跟类型说明符（如int, long等），那么它作用于
    类型说明符。在其他情况下，const和（或）volatile关键字作用于它左边紧邻的指针星号。
</code></pre>

<p>可以试着用优先级规则分析一下</p>

<pre><code>char * const *(*next)();
</code></pre>

<h2>3. 通过图表分析C语言的声明</h2>

<p>本节通过一张里面标明了分析步骤的图，按图索骥，从第一步开始，顺着箭头逐步往下分析，无论多么复杂的C语言声明都可以迎刃而解，都可以用最通俗的语言来解释。</p>

<p><img src="http://812lcl.github.io/images/blog/dcl.png" alt="解析C语言的声明" /></p>

<p>开始我们从左向右寻找，直到找到第一个标识符。当声明中的某个符号与图中所示匹配时，便把它从声明中处理掉，以后不再考虑。在具体的每一步骤上，我们首先查看右边的符号，再看左边的。</p>

<p>当所有的符号都被处理完毕后，便宣告大功告成。</p>

<p>可以试着用图表分析法分析上边的那个例子。</p>

<h2>4. 一个例子</h2>

<p>现在，我们再回头看一下之前提到的signal函数的声明。</p>

<pre><code>void (*signal(int, void(*)))(int);
</code></pre>

<p>首先标识符是signal，它右边紧跟了括号，则表示“signal是一个返回&hellip;的函数”；</p>

<p>这个函数有两个参数：一个是<code>int</code>型，一个是<code>void (*)</code>型的，即返回值为void的函数指针。</p>

<p>它的返回类型则是<code>void (*)(int)</code>型，即一个返回值为void，有一个int型参数的函数指针。</p>

<p>说着这么绕呢，其实现在看来这个声明还是挺清晰的了。signal函数的第二个参数就是信号处理函数的函数指针，信号处理函数接受一个int型参数，表示接到的是几号信号。</p>

<hr />

<p>其实可以编写一个能够分析C语言的声明，并把它们翻译成通俗语言的程序。可以通过堆栈实现，也可以用有限状态机来实现，都可以加深对复杂声明的理解，而且很好的练习编码。</p>

<h2>参考书籍</h2>

<ul>
<li><p>C专家编程</p></li>
<li><p>C陷阱与缺陷</p></li>
<li><p>C程序设计语言</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重学C语言(二)——运算符优先级与计算顺序]]></title>
    <link href="http://812lcl.com/blog/2013/12/21/zhong-xue-cyu-yan-er-yun-suan-fu-you-xian-ji-yu-ji-suan-shun-xu/"/>
    <updated>2013-12-21T14:36:00+08:00</updated>
    <id>http://812lcl.com/blog/2013/12/21/zhong-xue-cyu-yan-er-yun-suan-fu-you-xian-ji-yu-ji-suan-shun-xu</id>
    <content type="html"><![CDATA[<p>对于一个复杂的表达式，存在很多的运算符，要了解这个表达式的意义，就要了解清运算符之间的优先关系与结合顺序。要确保表达式实现自己所想达成的目的，了解计算顺序也是非常必要的。</p>

<h2>1. 运算符优先级与结合顺序</h2>

<p>复杂的表达式可能会有较多的运算符，有时候弄的头大，虽然可以添加括号来使表达式的意义更加明确，但有时候括号太多也会造成混乱，而更不容易理解。掌握C语言中的运算符优先级是非常必要的，也是非常有益的。</p>

<p>下表列出了各类运算符的优先级关系与结合顺序，表中由上至下，优先级依次递减。</p>

<!--more-->


<pre><code>运算符                                          结合性
() [] -&gt; .                                    自左向右
! ~ ++ -- + - (type) * &amp; sizeof               自右向左
* / %                                         自左向右
+ -                                           自左向右
&lt;&lt; &gt;&gt;                                         自左向右
&lt; &lt;= &gt; &gt;=                                     自左向右
== !=                                         自左向右
&amp;                                             自左向右
^                                             自左向右
|                                             自左向右
&amp;&amp;                                            自左向右
||                                            自左向右
?:                                            自右向左
assignments                                   自右向左
,                                             自左向右
</code></pre>

<p>15级的优先级，看似复杂难记，其实都是蕴含着一定的规律的。</p>

<p>首先，优先级最高的并不是真正意义上的运算符，如数组下标、函数调用操作符和结构成员选择符。它们的结合顺序都是自左向右的。如<code>a.b.c</code>表示<code>(a.b).c</code>，而不是<code>a.(b.c)</code>。</p>

<p>单目运算符的优先级仅次于上一种，是真正意义的运算符中优先级最高的。其中的<code>+ -</code>不是加号减号，而是正负号；<code>*</code>是表示指针，不是乘号。现在知道<code>*</code>的优先级是低于<code>[]</code>的，所以<code>int *p[10]</code>中表示p首先是一个数组，然后数组中的元素是一个指向int型的指针，即是一个指针数组。可见了解了运算符的优先级对于掌握复杂声名的分析也是有帮助的。单目运算符是自右向左结合的，所以<code>*p++</code>表示<code>*(p++)</code>而不是<code>(*p)++</code>。</p>

<p>接下来是双目运算符。在双目运算符中，算术运算符优先级最高，移位运算符次之，关系运算符再次之，然后是逻辑运算符，条件运算符，最后是各类赋值运算符。其中条件运算符是三目运算符。</p>

<p>需要记住的最重要的两点是：</p>

<ol>
<li><p>任何一个逻辑运算符的优先级低于任何一个关系运算符。</p></li>
<li><p>移位运算符的优先级比算术运算符要低，但高于关系运算符。</p></li>
</ol>


<p>算术运算符中乘除、取余优先于加减。关系运算符中注意一下，<code>== !=</code>的优先级低于其他四个关系运算符。</p>

<p>而逻辑运算符中任何两个都有不同的优先级，都是与关系高于或。<code>&amp; |</code>高于<code>&amp;&amp; ||</code>则是因为，前者在B语言中已经出现，而在B的基础上出现的C语言又加入了后者来区分不同的操作，从兼容性的角度，修改其优先顺序很危险。</p>

<p>条件运算符是唯一的三目运算符，优先级也是很低的，仅高于赋值运算符和逗号运算符。赋值运算符次之，这两类运算符的结合顺序是<code>自右向左</code>的。所以</p>

<pre><code>a=b=0;
</code></pre>

<p>等同于</p>

<pre><code>b=0;
a=0;
</code></pre>

<p>最后则是逗号运算符。被逗号分隔的一对表达式按照自左向右的顺序进行求值，表达式右边的操作数的类型和值即为其结果的类型和值。在for循环中常用逗号操作符，如下：</p>

<pre><code>for(i=0, j = strlen(s)-1; i &lt; j; i++, j--)
</code></pre>

<p>某些情况下的逗号并不是运算符，如分隔函数参数的逗号，分隔声明中变量的逗号等。这些逗号<code>并不保证各表达式自左向右的顺序求值</code>。应谨慎用逗号运算符，其最适用与关系紧密的结构中，如for循环、元素交换操作。</p>

<p>有时候表达式写的不规范或马虎，也会造成一些麻烦。如表达式<code>z = y+++x</code>，原本的意图可能是<code>z = y + ++x</code>或是<code>z = y++ + x</code>，但缺少了空格使人迷惑。ANSI C规定了一种逐渐为人所熟知的“maximal munch strategy”。这种策略表示如果下一个标记有超过一种的解决方案，编译器将选择能组成最长字符串序列的方案。所以这个表达式将被解析为后一种意思。但这也会造成一些麻烦，如<code>z = y+++++x</code>将被解析为<code>z = y++ ++ + x</code>就出现了错误。</p>

<p>所以当我们编写代码时，还是要认真一些，遵循一定的编程规范。</p>

<h2>2. 计算顺序</h2>

<p>讨论完了运算符优先级与结合顺序的问题，计算顺序则完全是另一码事了，不要和结合顺序搞混。C语言没有指定同一运算符中多个操作数的计算顺序（&amp;&amp;、||、?:和逗号运算符除外）。例如</p>

<pre><code>x = f() + g();
</code></pre>

<p>的语句中，f()可以在g()之前计算，也可以在其后计算。因此，如果两个函数改变了同一变量，则x的结果将依赖与两个函数的计算顺序。类似的，C语言也没有指定函数各参数的求值顺序。函数调用、嵌套赋值语句、自增、自减运算符都可能产生副作用。</p>

<p>在任何一门编程语言中，如果代码的执行结果与求值顺序相关，则都是不好的程序设计风格。</p>

<p>参考书籍</p>

<ul>
<li><p>C程序设计语言</p></li>
<li><p>C专家编程</p></li>
<li><p>C陷阱与缺陷</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重学C语言(一)——类型转换]]></title>
    <link href="http://812lcl.com/blog/2013/12/17/zhong-xue-cyu-yan-%5B%3F%5D-lei-xing-zhuan-huan/"/>
    <updated>2013-12-17T19:42:00+08:00</updated>
    <id>http://812lcl.com/blog/2013/12/17/zhong-xue-cyu-yan-[?]-lei-xing-zhuan-huan</id>
    <content type="html"><![CDATA[<h2>1. 整型提升</h2>

<p>在一个表达式中，凡是可以使用整型的地方都可以使用带符号或无符号的字符、短整型或整型位字段，还可以使用枚举类型的对象。如果原始类型的所有值都可用int类型表示，则其值将被转换为int类型；否则将被转换为unsigned int类型。这一过程称为整型提升。</p>

<p>以下面的代码为例：</p>

<p><code>printf(" %d ", sizeof'A');</code></p>

<p>这个代码本想打印出一个字符字面值类型的长度，但你会发现结果是4（或是你机器上int的长度）。这里就根据提升规则，由char转换为int。</p>

<!--more-->


<h2>2. 整型转换</h2>

<p>将任何整数转换为某种指定的无符号类型数的方法是：以该无符号类型能够表示的最大值加1为模，找出与此整数同余的最小的非负值。在对二的补码表示中，如果该无符号类型的为模式比较窄，这就相当于左截取；如果该无符号类型的为模式比较宽，这就相当于对带符号值进行符号扩展和对无符号值进行0填充。</p>

<p>将任何整数转换为带符号类型时，如果它可以在新类型中表示出来，则其值保持不变，否则它的值同具体的实现有关。</p>

<h2>3. 整数和浮点数</h2>

<p>当把浮点类型的值转换为整型时，小数部分将被丢弃。如果结果值不能用整型表示，则其行为是未定义的。特别是，将负的浮点数转换为无符号整型的结果是没有定义的。</p>

<p>当把整型值转换为浮点类型时，如果该值在该浮点类型可表示的范围内但不能精确表示，则结果可能是下一个较高或较低的可表示值。如果该值超出可表示的范围，则其行为是为定义的。</p>

<h2>4. 浮点类型</h2>

<p>将一个精度较低的浮点值转换为相同或更高精度的浮点类型时，它的值保持不变。将一个较高精度的浮点类型值转换为较低精度的浮点类型时，如果它的值在可表示范围内，则结果可能是下一个较高或较低的可表示值。如果结果在可表示范围之外，则其行为是为定义的。</p>

<p>表达式中的float类型的操作数不会自动转换为double类型。一般来说，数学函数使用double类型的变量。使用float类型主要是为了在使用较大的数组时节省存储空间，有时也为了节省机器执行时间（double算术运算特别费时）。</p>

<h2>5. 算术类型转换</h2>

<p>许多运算符都会以类似的方式在运算过程中引起转换，并产生结果类型。其效果是将所有操作数转换为同一公共类型，并以此作为结果的类型。这种方式的转换称为普通算术类型转换。</p>

<p>首先，如果任何一个操作数为long double类型，则将另一个操作数转换为long double类型。</p>

<p>否则，如果任何一个操作数为double类型，则将另一个操作数转换为double类型。</p>

<p>否则，如果任何一个操作数为float类型，则将另一个操作数转换为float类型。</p>

<p>否则，同时对两个操作数进行整型提升；然后，如果任何一个操作数为unsigned long int类型，则将另一个操作数转换为unsigned long int类型。</p>

<p>否则，如果一个操作数为long int类型且另一个操作数为unsigned int类型，则结果依赖于long int类型是否可以表示所有的unsigned int类型的值。如果可以，则将unsigned int类型的操作数转换为long int；如果不可以，则将两个操作数都转换为unsigned long int类型。</p>

<p>否则，如果一个操作数为long int类型，则将另一个操作数转换为long int类型。</p>

<p>否则，如果任何一个操作数为unsigned int类型，则将另一个操作数转换为unsigned int类型。</p>

<p>否则，将两个操作数都转换为int类型。</p>

<p>用通俗语言，大致意思如下：</p>

<blockquote><p>当执行算术运算时：操作数的类型如果不同，就会发生转换。数据类型一般朝着浮点精度更高，长度更长的方向转换，整型数如果转换为signed不会丢失信息，就转换为signed，否则转换为unsigned。</p></blockquote>

<p>例如，如果f为float类型，n为int类型，那么表达式</p>

<p><code>(n &gt; 0) ? f : n</code></p>

<p>是float类型，与n是否为正值无关。</p>

<h2>6. 参数传递中的类型转换</h2>

<p>在参数传递过程中会发生隐式类型转换，这是需要注意的地方。由于函数的参数也是表达式，所以也会发生类型提升。如果使用了适当的函数原型，类型提升便不会发生，否则也会发生。在被调用函数的内部，提升后的参数被裁剪为原先声明的大小。</p>

<p>ANSI C的函数原型就是采取一种新的函数声明形式，把参数的类型也包含于声明之中。</p>

<p>在C语言中，我们没有办法可以将一个数组作为参数直接传递。如果我们使用数组名作为参数，那么数组名会立刻被转换为指向数组第一个元素的指针。因此，将数组作为函数参数毫无意义。所以，C语言中会自动地将作为参数的数组声明转换为相应的指针声明。
<code>
实参                                所匹配的形式参数
数组的数组      char c[8][10];      char(*c)[10];    数组指针
指针数组        char *c[15];        char **c;       指针的指针
数组指针        char (*c)[64];      char (*c)[64];  不改变
指针的指针      char **c;           char **c;       不改变
</code>
你之所以能在main()函数中看到<code>char **argv</code>这样的参数，是因为argv是个指针数组(<code>char *argv[]</code>)。这个表达式被编译器改写为指向数组第一个元素的指针，也就是一个指向指针的指针。</p>

<h2>7. 指针和整数</h2>

<p>指针可以加上或减去一个整型表达式。在这种情况下，整型表达式的转换按照加法运算符的方法进行。</p>

<p>两个指向同一数组中同一类型的对象的指针可以进行减法运算，其结果将被转换为整型；转换方式按照减法的方式进行。</p>

<p>值为0的整型常量表达式或强制转换为void *类型的表达式可以通过强制类型转换、赋值或比较操作转换为任意类型的指针。其结果将产生一个空指针，此空指针等于指向同一类型的另一空指针，但不等于任何指向函数或对象的指针。</p>

<p>还允许进行指针相关的其他某些转换，但其结果依赖于具体实现。这些转换必须由一个显示的类型转换运算符或强制类型转换来指定。</p>

<p>指针可以转换为整型，但此整型必须足够大;所要求的大小依赖于具体的实现。映射函数也依赖于具体的实现。</p>

<p>整型对象可以显式地转换为指针。这种映射总是将一个足够宽的从指针转换来的整数转换为同一个指针，其他情况依赖于具体的实现。</p>

<p>指向某一类型的指针可以转换为指向另一类型的指针，但是，如果该指针指向的对象不满足一定的存储对齐要求，则结果指针可能会导致地址异常。指向某对象的指针可以转换为一个指向具有更小或相同存储对齐限制的对象的指针，并可以保证原封不动地再转回来。“对齐”的概念依赖于具体的实现，但char类型的对象具有最小的对齐限制。指针也可以转换为void * 类型，并可原封不动地转换回来。</p>

<p>一个指针可以转换为同类型的另一个指针，但增加或删除了指针所指的对象类型的限定符除外。如果增加了限定符，则新指针与原指针等价，不同的是增加了限定符带来的限制。如果删除了限定符，则对底层对象的运算仍受实际声明中的限定符的限制。</p>

<p>最后，指向一个函数的指针可以转换为指向另一个函数的指针。调用转换后指针所指的函数的结果依赖于具体的实现。但是，如果转换后的指针被重新转换为原来的类型，则结果与原来的指针一致。</p>

<h2>8. void</h2>

<p>void对象的值不能够以任何方式使用，也不能被显式或隐式地转换为任一非空类型。因为空（void）表达式表示一个不存在的值，这样的表达式只可以用在不需要值的地方，例如作为一个表达式语句或作为逗号运算符的做操作数。</p>

<p>可以通过强制类型转换将表达式转换为void类型。例如，在表达式语句中，一个空的强制类型转换将丢掉函数调用的返回值。</p>

<h2>9. 指向void的指针</h2>

<p>指向任何对象的指针都可以转换为void * 类型，且不会丢失信息。如果将结果再转换为初始指针类型，则可以恢复初始指针。之前讨论过，执行指针的转换时，一般需要显式的强制转换，这里不同的是，指针可以被赋值为void * 类型的指针，也可以赋值给void * 类型的指针，并可与void * 类型的指针进行比较。</p>

<h2>10. 强制类型转换</h2>

<p>之前都在说隐式类型转换，在任何表达式中都可以使用一个称为强制类型转换的一元运算符强制进行显式类型转换。</p>

<p>(类型名) 表达式</p>

<h3>参考文献</h3>

<ul>
<li><p>C程序设计语言</p></li>
<li><p>C专家编程</p></li>
<li><p>C缺陷与陷阱</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
